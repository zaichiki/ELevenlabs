<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Flashcard Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        input[type="text"],
        input[type="file"],
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
            display: block;
        }

        .cards-container {
            display: none;
        }

        .card-item {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .card-item.duplicate {
            border-color: #ffc107;
            background: #fff3cd;
        }

        .card-checkbox {
            flex-shrink: 0;
        }

        .card-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .card-content {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .card-field {
            display: flex;
            flex-direction: column;
        }

        .card-field label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 3px;
        }

        .card-field input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .duplicate-badge {
            background: #ffc107;
            color: #000;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-success {
            background: #28a745;
        }

        .progress {
            display: none;
            margin-top: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 10px;
        }

        .connection-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #dc3545;
            margin-right: 5px;
        }

        .connection-status.connected {
            background: #28a745;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-box {
            flex: 1;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: 700;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üá¨üá∑ Greek Flashcard Generator</h1>
            <p>Create Anki flashcards with Greek audio from ElevenLabs</p>
        </div>

        <div class="content">
            <!-- Configuration Section -->
            <div class="section">
                <h2 class="section-title">‚öôÔ∏è Configuration</h2>
                
                <div class="form-group">
                    <label>
                        <span class="connection-status" id="ankiStatus"></span>
                        Connection Status
                    </label>
                </div>

                <div class="form-group">
                    <label>üé§ ElevenLabs Voice</label>
                    <select id="voiceSelect" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1em;">
                        <option value="ejJ1ETWS2ohLMMeCu1H3">Atlas The Greek</option>
                        <option value="pNInz6obpgDQGcFmaJgB">Adam (Multilingual)</option>
                        <option value="ErXwobaYiN019PkySvjV">Antoni (Multilingual)</option>
                        <option value="VR6AewLTigWG4xSOukaG">Arnold (Multilingual)</option>
                        <option value="EXAVITQu4vr4xnSDxMaL">Bella (Multilingual)</option>
                        <option value="21m00Tcm4TlvDq8ikWAM">Rachel (Multilingual)</option>
                        <option value="AZnzlk1XvdvUeBnXmlld">Domi (Multilingual)</option>
                        <option value="MF3mGyEYCl7XYWbV9V6O">Elli (Multilingual)</option>
                    </select>
                </div>
            </div>

            <!-- Status Messages -->
            <div id="statusMessage" class="status"></div>

            <!-- Input Section -->
            <div class="section">
                <h2 class="section-title">üìù Input Flashcard Text</h2>
                <div class="form-group">
                    <label>Paste your text (Greek + English on one line, Russian on next line)</label>
                    <textarea id="textInput" rows="20" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1em; font-family: monospace; resize: vertical;" placeholder="ŒöŒ±ŒªŒ∑ŒºŒ≠œÅŒ±; Good morning!&#10;–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ!&#10;ŒòŒ≠Œªœâ ŒΩŒµœÅœå. I want water.&#10;–•–æ—á—É –≤–æ–¥—ã."></textarea>
                </div>
                <button onclick="processText()">Process Text</button>
            </div>

            <!-- Cards Section -->
            <div class="section cards-container" id="cardsSection">
                <h2 class="section-title">üìù Review Flashcards</h2>
                
                <div class="stats" id="stats">
                    <div class="stat-box">
                        <div class="stat-number" id="totalCards">0</div>
                        <div class="stat-label">Total Cards</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-number" id="selectedCards">0</div>
                        <div class="stat-label">Selected</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-number" id="duplicateCards">0</div>
                        <div class="stat-label">Duplicates</div>
                    </div>
                </div>

                <div class="button-group">
                    <button onclick="selectAll()">Select All</button>
                    <button onclick="deselectAll()">Deselect All</button>
                    <button onclick="generateAllExplanations()" style="background: #ff9800;">ü§ñ Generate All Explanations</button>
                    <button class="btn-success" onclick="createCards()">Create Selected Cards</button>
                </div>

                <div class="progress" id="progressBar">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                </div>

                <div id="cardsContainer"></div>
            </div>
        </div>
    </div>

    <script>
        let sessionId = null;
        let cards = [];
        let duplicates = {};

        // Initialize
        window.addEventListener('load', () => {
            loadConfiguration();
        });

        async function loadConfiguration() {
            try {
                const response = await fetch('/api/config');
                const config = await response.json();
                
                // Store all config for later
                window.ankiConnectUrl = config.ankiConnectUrl;
                window.elevenLabsApiKey = config.elevenLabsApiKey;
                window.geminiApiKey = config.geminiApiKey;
                window.defaultVoiceId = config.defaultVoiceId;
                window.defaultDeck = config.defaultDeck;
                window.defaultModel = config.defaultModel;
                
                // Set the voice selector to the default
                const voiceSelect = document.getElementById('voiceSelect');
                if (voiceSelect && config.defaultVoiceId) {
                    voiceSelect.value = config.defaultVoiceId;
                }
                
                testAnkiConnection();
            } catch (error) {
                console.error('Error loading configuration:', error);
                testAnkiConnection();
            }
        }

        async function testAnkiConnection() {
            const url = window.ankiConnectUrl || "http://localhost:8765";
            const statusEl = document.getElementById('ankiStatus');
            
            try {
                const response = await fetch(`/api/anki/test?url=${encodeURIComponent(url)}`);
                const data = await response.json();
                
                if (data.connected) {
                    statusEl.classList.add('connected');
                    showStatus(`‚úÖ AnkiConnect connected! Version: ${data.version}`, 'success', true);
                } else {
                    statusEl.classList.remove('connected');
                    let errorMsg = data.error;
                    if (data.details) {
                        errorMsg += ` (${data.details})`;
                    }
                    showStatus(`‚ùå AnkiConnect: ${errorMsg}`, 'error', true);
                }
            } catch (error) {
                statusEl.classList.remove('connected');
                showStatus(`‚ùå Error testing AnkiConnect: ${error.message}`, 'error', true);
            }
        }


        async function processText() {
            const textInput = document.getElementById('textInput');
            const text = textInput.value.trim();
            
            if (!text) {
                showStatus('Please enter some text', 'error');
                return;
            }

            try {
                showStatus('Processing text...', 'info');
                const response = await fetch('/api/cards/parse', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text })
                });

                const data = await response.json();
                sessionId = data.sessionId;
                cards = data.cards;
                
                document.getElementById('cardsSection').style.display = 'block';
                showStatus(`Parsed ${cards.length} cards, checking for duplicates...`, 'info');
                
                // Automatically check for duplicates
                await checkDuplicates();
                
                renderCards();
                updateStats();
            } catch (error) {
                showStatus(`Error processing text: ${error.message}`, 'error');
            }
        }

        function renderCards() {
            const container = document.getElementById('cardsContainer');
            container.innerHTML = cards.map(card => `
                <div class="card-item ${duplicates[card.id] ? 'duplicate' : ''}" id="card-${card.id}">
                    <div class="card-checkbox">
                        <input type="checkbox" 
                               ${card.selected ? 'checked' : ''} 
                               onchange="toggleCard('${card.id}', this.checked)">
                    </div>
                    <div class="card-content">
                        <div class="card-field">
                            <label>Greek (Front)</label>
                            <input type="text" 
                                   value="${escapeHtml(card.greek)}" 
                                   onchange="updateCard('${card.id}', 'greek', this.value)">
                        </div>
                        <div class="card-field">
                            <label>Translation (Back)</label>
                            <textarea rows="3" 
                                      style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: inherit; resize: vertical;"
                                      onchange="updateCard('${card.id}', 'translation', this.value)">${escapeHtml(card.translation)}</textarea>
                        </div>
                        <div class="card-field" style="grid-column: 1 / -1;">
                            <label>üí° Russian Explanation 
                                <button onclick="generateExplanation('${card.id}')" 
                                        style="padding: 4px 12px; font-size: 0.85em; margin-left: 8px;"
                                        title="Generate explanation using Gemini AI">
                                    ü§ñ Auto-Generate
                                </button>
                            </label>
                            <textarea rows="2" 
                                      id="explanation-${card.id}"
                                      style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: inherit; resize: vertical;"
                                      onchange="updateCard('${card.id}', 'russianExplanation', this.value)">${escapeHtml(card.russianExplanation || '')}</textarea>
                        </div>
                    </div>
                    ${duplicates[card.id] ? '<span class="duplicate-badge">DUPLICATE</span>' : ''}
                </div>
            `).join('');
        }

        async function checkDuplicates() {
            if (!sessionId) return;

            const ankiUrl = window.ankiConnectUrl || "http://localhost:8765";
            const deckName = window.defaultDeck || "EL Custom Deck";
            
            try {
                const response = await fetch('/api/cards/check-duplicates', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId, ankiConnectUrl: ankiUrl, deckName })
                });

                duplicates = await response.json();
                
                // Deselect all duplicate cards
                cards.forEach(card => {
                    if (duplicates[card.id]) {
                        card.selected = false;
                    }
                });
                
                const dupCount = Object.values(duplicates).filter(d => d).length;
                if (dupCount > 0) {
                    showStatus(`‚úÖ Parsed ${cards.length} cards. Found ${dupCount} duplicate(s) - auto-deselected.`, 'success');
                } else {
                    showStatus(`‚úÖ Parsed ${cards.length} cards. No duplicates found.`, 'success');
                }
            } catch (error) {
                showStatus(`Parsed ${cards.length} cards. Error checking duplicates: ${error.message}`, 'error');
            }
        }

        async function createCards() {
            if (!sessionId) return;

            const apiKey = window.elevenLabsApiKey;
            if (!apiKey) {
                showStatus('ElevenLabs API key not configured in appsettings.json', 'error');
                return;
            }

            const selectedCards = cards.filter(c => c.selected);
            if (selectedCards.length === 0) {
                showStatus('No cards selected', 'error');
                return;
            }

            const voiceSelect = document.getElementById('voiceSelect');
            const voiceId = voiceSelect ? voiceSelect.value : (window.defaultVoiceId || "ejJ1ETWS2ohLMMeCu1H3");
            const deckName = window.defaultDeck || "Default";
            const modelName = window.defaultModel || "Basic";
            const ankiUrl = window.ankiConnectUrl || "http://localhost:8765";

            try {
                document.getElementById('progressBar').style.display = 'block';
                updateProgress(0, selectedCards.length, 'Starting...');
                
                let successCount = 0;
                let failCount = 0;
                
                // Create cards one by one to show progress
                for (let i = 0; i < selectedCards.length; i++) {
                    const card = selectedCards[i];
                    const cardNum = i + 1;
                    
                    updateProgress(cardNum, selectedCards.length, `Creating: ${card.greek}`);
                    
                    try {
                        const response = await fetch('/api/cards/create-single', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                sessionId,
                                cardId: card.id,
                                elevenLabsApiKey: apiKey,
                                voiceId: voiceId || null,
                                deckName,
                                modelName,
                                ankiConnectUrl: ankiUrl
                            })
                        });
                        
                        const result = await response.json();
                        if (result.success) {
                            successCount++;
                        } else {
                            failCount++;
                            console.error(`Failed to create card: ${card.greek}`, result.error);
                        }
                    } catch (error) {
                        failCount++;
                        console.error(`Error creating card: ${card.greek}`, error);
                    }
                }

                document.getElementById('progressBar').style.display = 'none';
                
                if (failCount === 0) {
                    showStatus(`‚úÖ Successfully created ${successCount} card(s)!`, 'success');
                } else {
                    showStatus(`Created ${successCount} card(s), ${failCount} failed`, 'error');
                }
            } catch (error) {
                document.getElementById('progressBar').style.display = 'none';
                showStatus(`Error creating cards: ${error.message}`, 'error');
            }
        }
        
        function updateProgress(current, total, message) {
            const percentage = Math.round((current / total) * 100);
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = percentage + '%';
            progressFill.textContent = `${percentage}% - ${message}`;
            showStatus(`[${current}/${total}] ${message}`, 'info', true);
        }

        function toggleCard(cardId, selected) {
            const card = cards.find(c => c.id === cardId);
            if (card) {
                card.selected = selected;
                updateStats();
            }
        }

        async function updateCard(cardId, field, value) {
            const card = cards.find(c => c.id === cardId);
            if (!card) return;

            card[field] = value;

            try {
                await fetch(`/api/cards/${sessionId}/${cardId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(card)
                });
            } catch (error) {
                console.error('Error updating card:', error);
            }
        }

        async function generateExplanation(cardId) {
            const card = cards.find(c => c.id === cardId);
            if (!card) return;

            const apiKey = window.geminiApiKey;
            if (!apiKey) {
                showStatus('Gemini API key not configured in appsettings.json', 'error');
                return;
            }

            const explanationField = document.getElementById(`explanation-${cardId}`);
            if (explanationField) {
                explanationField.value = '–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–±—ä—è—Å–Ω–µ–Ω–∏—è...';
                explanationField.disabled = true;
            }

            try {
                // Extract English from translation (first line)
                const englishTranslation = card.translation.split('\n')[0];
                
                const response = await fetch('/api/gemini/explain', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        greek: card.greek,
                        english: englishTranslation,
                        apiKey: apiKey
                    })
                });

                const result = await response.json();
                
                if (result.explanation) {
                    card.russianExplanation = result.explanation;
                    if (explanationField) {
                        explanationField.value = result.explanation;
                    }
                    await updateCard(cardId, 'russianExplanation', result.explanation);
                    showStatus('‚úÖ Explanation generated successfully!', 'success');
                } else {
                    throw new Error('No explanation returned');
                }
            } catch (error) {
                showStatus(`Error generating explanation: ${error.message}`, 'error');
                if (explanationField) {
                    explanationField.value = card.russianExplanation || '';
                }
            } finally {
                if (explanationField) {
                    explanationField.disabled = false;
                }
            }
        }

        async function generateAllExplanations() {
            const apiKey = window.geminiApiKey;
            if (!apiKey) {
                showStatus('Gemini API key not configured in appsettings.json', 'error');
                return;
            }

            const cardsWithoutExplanation = cards.filter(c => !c.russianExplanation || c.russianExplanation.trim() === '');
            if (cardsWithoutExplanation.length === 0) {
                showStatus('All cards already have explanations!', 'info');
                return;
            }

            showStatus(`Generating explanations for ${cardsWithoutExplanation.length} cards...`, 'info', true);

            let successCount = 0;
            let failCount = 0;

            for (let i = 0; i < cardsWithoutExplanation.length; i++) {
                const card = cardsWithoutExplanation[i];
                showStatus(`[${i + 1}/${cardsWithoutExplanation.length}] Generating for: ${card.greek}`, 'info', true);
                
                try {
                    const englishTranslation = card.translation.split('\n')[0];
                    
                    const response = await fetch('/api/gemini/explain', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            greek: card.greek,
                            english: englishTranslation,
                            apiKey: apiKey
                        })
                    });

                    const result = await response.json();
                    
                    if (result.explanation) {
                        card.russianExplanation = result.explanation;
                        await updateCard(card.id, 'russianExplanation', result.explanation);
                        successCount++;
                    } else {
                        failCount++;
                    }
                } catch (error) {
                    console.error(`Error generating explanation for ${card.greek}:`, error);
                    failCount++;
                }
                
                // Small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            renderCards();
            
            if (failCount === 0) {
                showStatus(`‚úÖ Successfully generated ${successCount} explanations!`, 'success');
            } else {
                showStatus(`Generated ${successCount} explanations, ${failCount} failed`, 'error');
            }
        }

        function selectAll() {
            cards.forEach(c => c.selected = true);
            renderCards();
            updateStats();
        }

        function deselectAll() {
            cards.forEach(c => c.selected = false);
            renderCards();
            updateStats();
        }


        function updateStats() {
            document.getElementById('totalCards').textContent = cards.length;
            document.getElementById('selectedCards').textContent = cards.filter(c => c.selected).length;
            document.getElementById('duplicateCards').textContent = Object.values(duplicates).filter(d => d).length;
        }

        function showStatus(message, type, keepVisible = false) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            
            if ((type === 'success' || type === 'info') && !keepVisible) {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>

